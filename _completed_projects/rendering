---
layout: single          # use single so TOC is available
author_profile: false
toc: true
classes: wide
permalink: /completed_projects/rendering/
title: "A Rendering Project"
excerpt: "A Rendering Project With Feature Lines & Attribute Based Mapping"

header:
  teaser: /assets/images/rendering/cover.jpg
  overlay_color: "#000"
  overlay_filter: 0.7
  overlay_image: /assets/images/rendering/bg.jpg
  actions:
    - label: "GitHub"
      url: "https://github.com/KoS-Y1/RenderingProject"
  caption: "Screenshot of my rendering project"

# Optional info block (not a built-in MM sidebar componentâ€”just data you can render manually if you want)
sidebar:
  - title: "Type"
    text: "3D Rendering Research Project"
  - title: "Programming Language"
    text: "C++"
  - title: "Engine Libraries"
    text: "OpenGL"
  - title: "Highlight"
    text: "Feature Lines; Attribute Based Mapping"
  - title: "Team"
    text: "Solo"
  - title: "Work Period"
    text: "Jan 2021"

screenshots:
  - url: /assets/images/tesla/1.png
    image_path: /assets/images/tesla/1.png
  - url: /assets/images/tesla/2.png
    image_path: /assets/images/tesla/2.png
  - url: /assets/images/tesla/multi.png
    image_path: /assets/images/tesla/multi.png

---

{% include feature_row %}

**This is one of my early projects.**
{: .notice--danger}

## Motivation & Goal

To achivement a good non-photorealistic rendering effect.

In attribute-based mapping, we rely on the different texture for differnt color, my goal is to let users be able to select the input color.

## Features

### Feature Lines (Silhouette & Crease)

Instead of post processing edge detection, the program using edge buffer to detect silhouette, and a threshold of angle between two front-facing polygons to detect crease edges.

[!silhouette](/assets/images/rendering/silhouette.png)

```
//adjacent list
struct Node {
    unsigned int v;                     //vertex id(index)
    unsigned int f = 0;                 //front face bit
    unsigned int b = 0;                 //back face bit
    std::vector<glm::vec3> norms;       //normals of 2 faces
};

// detect silhouette
for (int j = 0; j < edgeBuffer.size(); ++j) {
    Vertex v0, v1;
    for (auto it = edgeBuffer[j].begin(); it != edgeBuffer[j].end(); ++it) {
        //if front bit and back bit are both 1, which means it is a silhooute
        if ((*it).b && (*it).f) {
            v0 = ourModel.meshes[0].vertices[j];
            v1 = ourModel.meshes[0].vertices[(*it).v];
            //cout << j << " "  << (*it).v << " " << (*it).b << " " << (*it).f << endl;
            vertices.push_back(v0.Position);
            vertices.push_back(v1.Position);
        }
    }
}

// detect crease
for (int j = 0; j < edgeBuffer.size(); ++j) {
  Vertex v0, v1;
  for (auto it = edgeBuffer[j].begin(); it != edgeBuffer[j].end(); ++it) {
      //if it's front face
      if (!(*it).f && !(*it).b) {
          v0 = ourModel.meshes[0].vertices[j];
          v1 = ourModel.meshes[0].vertices[(*it).v];
          if (it->norms.size() >= 2) {
              glm::vec3 norm1 = it->norms[0];vec3 rgbTohsv(vec3 c)vec3 rgbTohsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsvTorgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsvTorgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
              glm::vec3 norm2 = it->norms[1];
              if (glm::dot(norm1, norm2) <= glm::cos(glm::radians(180.f - creaseAngle))) {
                  vertices.push_back(v0.Position);
                  vertices.push_back(v1.Position);
              }
          }
      }
  }
}

### Texture
Based on [RGB to HSV](http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl), I designed shader function to do conversion between RGB and HSV color space.

```
vec3 rgbTohsv(vec3 c)vec3 rgbTohsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsvTorgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
  
```

Then I applied my color theory knowledge, that in real world, object colors change in sunlight scenes because cool skylight and warm sunlight vary in relative contribution across the surface. so kin real world, object colors change in sunlight scenes because cool skylight and warm sunlight vary in relative contribution across the surface, to add hue changes.

![Hue Changes](/assets/images/rendering/hue.png)

so I applied the user selcted color with a grayscale texture, then add the slight hue changes.

## Gallary  
In the end, we achived a nice non-photorealistic rendering effect as shown below:
![Result](/assets/images/rendering/result.jpg)